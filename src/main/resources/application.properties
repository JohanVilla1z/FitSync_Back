# Configuración básica de la aplicación
spring.application.name=GymControl

# Configuración de logging para producción
logging.level.root=WARN
logging.level.com.johan=INFO
logging.level.org.springframework.web=INFO
logging.level.org.hibernate.SQL=WARN
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

# Configuración de la base de datos (usando variables de entorno de Render/Docker/Railway)
# Los valores predeterminados (:localhost, :3306, etc.) son para ejecución local si las variables no están definidas.
spring.datasource.url=jdbc:mysql://${MYSQLHOST:localhost}:${MYSQLPORT:3306}/${MYSQLDATABASE:gym_control}?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true
# Uses MYSQLUSER env var (provided by Railway) or defaults to 'root'
spring.datasource.username=${MYSQLUSER:root}
# Uses MYSQL_ROOT_PASSWORD env var (provided by Railway) or defaults to '1234' for local development.
spring.datasource.password=${MYSQL_ROOT_PASSWORD:1234}
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# Eliminando el dialect explícito para que Hibernate seleccione el adecuado automáticamente
# spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

# Configuración de HikariCP (pool de conexiones)
# Valores ajustados para Railway/Producción, pueden usar variables de entorno también si se desea.
# Tiempo de espera para obtener una conexión
spring.datasource.hikari.connection-timeout=${DB_CONN_TIMEOUT:20000}
# Conexiones inactivas mínimas
spring.datasource.hikari.minimum-idle=${DB_MIN_IDLE:5}
# Tamaño máximo del pool
spring.datasource.hikari.maximum-pool-size=${DB_MAX_POOL_SIZE:12}
# Tiempo máximo que una conexión puede estar inactiva (5 min)
spring.datasource.hikari.idle-timeout=${DB_IDLE_TIMEOUT:300000}
# Tiempo máximo de vida de una conexión (20 min)
spring.datasource.hikari.max-lifetime=${DB_MAX_LIFETIME:1200000}
spring.datasource.hikari.auto-commit=true

# Configuración del puerto (importante para Heroku/Render)
server.port=${PORT:8080}
# Enlazar a 0.0.0.0 para ser accesible dentro del contenedor de Render
server.address=0.0.0.0

# Configuración SSL para producción
server.forward-headers-strategy=NATIVE
server.tomcat.remoteip.remote-ip-header=x-forwarded-for
server.tomcat.remoteip.protocol-header=x-forwarded-proto

# Configuración de JPA
# Usar variable de entorno o 'update' por defecto
spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}
# Usar variable de entorno o 'false' por defecto
spring.jpa.show-sql=${SPRING_JPA_SHOW_SQL:false}
# Comentado: Hibernate detectará el dialecto automáticamente (Resuelve HHH90000025)
# spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
spring.jpa.properties.hibernate.format_sql=${FORMAT_SQL:true}
# Recomendado poner a false por rendimiento
spring.jpa.open-in-view=false

# Configuración de JWT (usa variables de entorno para mayor seguridad)
# Ensure JwtService and UserDetailsService beans are correctly configured and injected in JwtAuthenticationFilter if DB issues are resolved but this error persists.
jwt.secret=${JWT_SECRET:wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY}
jwt.expiration=${JWT_EXPIRATION:86400000}

# Configuración de CORS para permitir peticiones desde el frontend
# Permite múltiples orígenes separados por comas
spring.mvc.cors.allowed-origins=${ALLOWED_ORIGINS:http://localhost:5173,https://fitsync.netlify.app,https://fitsync-app.netlify.app}
spring.mvc.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,PATCH
spring.mvc.cors.allowed-headers=Authorization,Content-Type,X-Requested-With,Accept,Origin,Access-Control-Request-Method,Access-Control-Request-Headers
spring.mvc.cors.exposed-headers=Authorization,Content-Disposition
spring.mvc.cors.allow-credentials=true
spring.mvc.cors.max-age=3600

# Configuración para DataSeeder
seed.admin.email=${SEED_ADMIN_EMAIL:admin@fitsync.com}
seed.admin.password=${SEED_ADMIN_PASSWORD:Admin123!}
seed.trainer.email=${SEED_TRAINER_EMAIL:trainer@fitsync.com}
seed.trainer.password=${SEED_TRAINER_PASSWORD:Trainer123!}
seed.user.email=${SEED_USER_EMAIL:user@fitsync.com}
seed.user.password=${SEED_USER_PASSWORD:User123!}
spring.profiles.active=${ACTIVE_PROFILE:default}

# Configuración de seguridad adicional
server.servlet.session.cookie.secure=${SECURE_COOKIE:true}
server.servlet.session.cookie.http-only=true
server.servlet.session.cookie.same-site=strict

# Configuración de límite de tasa (Rate Limiting)
resilience4j.ratelimiter.instances.api.limit-for-period=100
resilience4j.ratelimiter.instances.api.limit-refresh-period=1m
resilience4j.ratelimiter.instances.api.timeout-duration=0
resilience4j.ratelimiter.instances.authapi.limit-for-period=20
resilience4j.ratelimiter.instances.authapi.limit-refresh-period=1m
resilience4j.ratelimiter.instances.authapi.timeout-duration=0

# Configuración de SpringDoc OpenAPI
springdoc.api-docs.path=/v3/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method
springdoc.api-docs.enabled=${ENABLE_API_DOCS:true}
springdoc.swagger-ui.enabled=${ENABLE_SWAGGER_UI:true}
springdoc.packages-to-scan=com.johan.gym_control.controllers
springdoc.pathsToMatch=/api/**
springdoc.swagger-ui.disable-swagger-default-url=true
springdoc.version=3.0.0
springdoc.writer-with-order-by-keys=true
springdoc.swagger-ui.tagsSorter=alpha
springdoc.swagger-ui.filter=true
springdoc.swagger-ui.csrf.enabled=false

# Solución al problema de la versión OpenAPI - Commenting out as it might hide underlying issues
# springdoc.api-docs.version=OPENAPI_3_0